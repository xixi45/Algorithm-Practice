/*
1. Two Sum (两数之和)
题目链接: https://leetcode.cn/problems/two-sum/
 
[题目简述]
给定一个整数数组 nums 和一个整数目标值 target。
要求：在数组中找出和为目标值 target 的那两个整数，并返回它们的数组下标。
假设：每种输入只会对应一个答案，且不能使用同一个元素两次。 
[核心思路 - 暴力枚举]
1. 外层循环：固定第一个数 nums[i]，i 从 0 遍历到 nums.size()-2。
2. 内层循环：枚举第二个数 nums[j]，j 从 i+1 遍历到 nums.size()-1。
3. 检查条件：如果 nums[i] + nums[j] == target，立即返回下标 {i, j}。

[复杂度分析]
时间复杂度：O(n²)，其中 n 是数组长度。最坏情况下需检查所有 C(n,2) = n(n-1)/2 对组合。
空间复杂度：O(1)，只使用了常数级的额外变量 (i, j)。
[算法标签] [数组]、[暴力枚举]
*/
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        
        // 方法一：双层循环暴力枚举
        // 外层循环：依次将每个元素作为第一个加数
        for (int i = 0; i < nums.size() - 1; ++i) { // i只需走到倒数第二个元素
            // 内层循环：枚举在 i 之后的所有元素作为第二个加数
            // 从 i+1 开始可以确保：1) 不重复使用同一元素；2) 避免重复检查 (i,j) 和 (j,i)
            for (int j = i + 1; j < nums.size(); ++j) {
                // 判断当前组合是否符合条件
                if (nums[i] + nums[j] == target) {
                    // 找到答案，按题目要求顺序返回下标
                    return {i, j}; // 使用列表初始化，简洁高效
                }
            }
        }
        // 根据题目保证，理论上不会执行到这里。返回空向量表示未找到。
        return {};
    }
};
/*
 [复盘与总结]
1.这是最直观的解法，适合作为解题的起点，帮助理解问题本质。
2.一个关键易错点：必须理解函数的行为。
我一开始把return{i,j};写成cout<<nums[i]<<" "<<nums[j];后面了解了
cout 是“输出”：它只是将内容打印到你的本地控制台，力扣的服务器根本看不到。
return {} 是“真正的返回”：函数最终返回了一个空的向量 {}。
* 核心：`cout` 用于给人看（调试），`return` 用于给程序（调用者）传递结果。
3.优化空间：此解法存在大量重复计算。例如，对于 nums[i]，我们需要反复计算 target - num[i]。
4.进阶思考：如何优化？
→ 使用哈希表（unordered_map）存储<数值, 下标>，可将查找时间降至 O(1)。
→ 新思路：遍历时，检查“当前数所需的搭档 (target - nums[i])”是否已在哈希表中。
→ 优化后复杂度：时间 O(n)，空间 O(n)。（典型的“以空间换时间”）
5. 面试提示：即使首先想到暴力法，也应主动分析其缺点并提出优化方案，展示思维过程。
*/